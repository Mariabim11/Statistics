<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HW7 - Simulation</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css">
    <style>
        body {
            background-color: #f4f4f9;
            font-family: Arial, sans-serif;
            color: #333;
            margin: 0;
            padding: 0;
        }
        header {
            background-color: #6a1b9a;
            color: white;
            padding: 20px;
            text-align: center;
        }
        main {
            padding: 20px;
        }
        form {
            display: flex;
            flex-direction: column;
            max-width: 400px;
            margin: 20px auto;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        label, select, input {
            font-size: 16px;
            margin-bottom: 10px;
            width: 100%;
        }
        input[type="button"] {
            background-color: #6a1b9a;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        input[type="button"]:hover {
            background-color: #4a0072;
        }
        canvas {
            background-color: rgba(240, 240, 200, 0.5);
            width: 100%;
            height: 300px;
        }
    </style>
</head>
<body>
    <header>
        <h1>HW7 - Simulation</h1>
    </header>
    <main>
        <form id="f1">
            <label for="selectOption">Select Option:</label>
            <select class="form-select" id="selectOption">
                <option value="option1">General Brownian Motion</option>
                <option value="option2">Standard Brownian Motion</option>
                <option value="option3">Geometric Brownian Motion</option>
                <option value="option4">Ornstein Uhlenbeck</option>
                <option value="option5">Vasicek Model</option>
                <option value="option6">Bernoulli</option>
                <option value="option7">Random Walk</option>
                <option value="option8">Poisson</option>
            </select>
            <div id="parameters">
                <label for="numberN">N:</label>
                <input type="number" id="numberN" placeholder="Number of intervals" value="30" required>
                <label for="numberM">M:</label>
                <input type="number" id="numberM" placeholder="Number of systems" value="20" required>
                <label for="Probability">Probability:</label>
                <input type="number" step="0.01" id="Probability" placeholder="Attack ratio" value="0.5" required>
                <label for="numberA">Attack Histogram:</label>
                <input type="number" id="numberA" placeholder="Attack's number for histogram" value="10" required>
                <label for="Lambda">Lambda:</label>
                <input type="number" id="Lambda" placeholder="Value of Lambda" value="10" required>
                <label for="sigmaValue">Sigma:</label>
                <input type="number" step="0.01" id="sigmaValue" placeholder="Value of Sigma" value="0.2" required>
                <label for="muValue">Mu:</label>
                <input type="number" step="0.01" id="muValue" placeholder="Value of Mu" value="0.1" required>
                <label for="thetaValue">Theta:</label>
                <input type="number" step="0.01" id="thetaValue" placeholder="Value of Theta" value="0.1" required>
                <label for="kValue">K:</label>
                <input type="number" step="0.01" id="kValue" placeholder="Value of K" value="0.1" required>
            </div>
            <input type="button" value="Send" onclick="collectData()">
        </form>
        <canvas id="myCanvas"></canvas>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <script>
        "use strict";
        function setCanvasWidthToScreenWidth() {
            "use strict";
            const canvas = document.getElementById('myCanvas');
            const screenWidth = window.innerWidth * 1;
            const screenHeight = window.innerHeight;
            canvas.width = screenWidth;
            canvas.height = screenHeight;
        }
    
        window.addEventListener('load', () => {
            setCanvasWidthToScreenWidth();
        });
    
        window.addEventListener('resize', setCanvasWidthToScreenWidth);
    </script>
    
    <script>
    
        class Rect {
            constructor(x, y, width, height, idRect) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.gridSpacing = 8;
                this.gridXini = x;
                this.gridXfin = x + width;
                this.gridYini = y;
                this.gridYfin = y + height;
                this.offsetViewX = 0.0;
                this.offsetViewY = 0.0;
                this.id = idRect;
                this.gxi = 0;
                this.gxf = 0;
                this.gyi = 0;
                this.gyf = 0;
            }
            
            drawGridLines(x1, y1, x2, y2, color) {
             ctx.beginPath();
             ctx.moveTo(x1, y1);
             ctx.lineTo(x2, y2);
             ctx.strokeStyle = color;
             ctx.stroke();
            }
    
            draw() {
                let numRows = 2 * N;
                let numCols = N;
                if(!continuosOptions.includes(selectOption.value)){
                    this.drawGrid(this.gridXini, this.gridXfin, this.gridYini, this.gridYfin, numRows, numCols, Math.abs((this.gridYfin-this.gridYini)/numRows), Math.abs((this.gridXfin-this.gridXini)/numCols));
                }else{
                    this.drawGrid(this.gxi, this.gxf, this.gyi, this.gyf, numRows, numCols, Math.abs((this.gridYfin-this.gridYini)/numRows), Math.abs((this.gridXfin-this.gridXini)/numCols));
                }
                drawChart(this);
                drawRectanglePerimeter(this);
                drawHistogram(this,A, dataForHistogram, labelsForHistogram);
                drawHistogram(this, N, dataForHistogramFine, labelsForHistogramFine);
                if(!continuosOptions.includes(selectOption.value)){
                    this.drawAxes(this.gridXini, this.gridXfin, this.gridYini, this.gridYfin);
                }else{
                    this.drawAxes(this.gxi, this.gxf, this.gyi, this.gyf);
                }
            }
    
            drawGrid(gridXini, gridXfin, gridYini, gridYfin, numRows, numCols, dimRows, dimCols) {
                const gridSize = this.gridSpacing;
    
                ctx.save();
                ctx.beginPath();
                ctx.rect(this.x, this.y, this.width, this.height);
                ctx.clip();
    
                if(gridYini + this.offsetViewY < gridYfin + this.offsetViewY){
                    for (let y = gridYini + this.offsetViewY; y <= gridYfin + this.offsetViewY; y += dimRows) {
                        let xGrigliaSx = gridXini + this.offsetViewX;
                        let xGrigliaDx = gridXfin + this.offsetViewX;
    
                        let ris = drawInsideRectangle(this, xGrigliaSx, y, xGrigliaDx, y);
                        if(ris != null){
                            ctx.beginPath();
                            ctx.moveTo(ris[0], ris[1]);
                            ctx.lineTo(ris[2], ris[3]);
                            ctx.strokeStyle = 'white';
                            ctx.stroke();
                        }
                    }
                }else{
                    for (let y = gridYfin + this.offsetViewY; y <= gridYini + this.offsetViewY; y += dimRows) {
                        let xGrigliaSx = gridXini + this.offsetViewX;
                        let xGrigliaDx = gridXfin + this.offsetViewX;
    
                        let ris = drawInsideRectangle(this, xGrigliaSx, y, xGrigliaDx, y);
                        if(ris != null){
                            ctx.beginPath();
                            ctx.moveTo(ris[0], ris[1]);
                            ctx.lineTo(ris[2], ris[3]);
                            ctx.strokeStyle = 'white';
                            ctx.stroke();
                        }
                    }
                }
    
                if(gridXini + this.offsetViewX < gridXfin + this.offsetViewX){
                    for (let x = gridXini + this.offsetViewX; x <= gridXfin + this.offsetViewX; x += dimCols) {
                        let yGrigliaSopra = gridYini + this.offsetViewY;
                        let yGrigliaSotto = gridYfin + this.offsetViewY;
    
                        let ris = drawInsideRectangle(this, x, yGrigliaSopra, x, yGrigliaSotto);
                        if(ris != null){
                            ctx.beginPath();
                            ctx.moveTo(ris[0], ris[1]);
                            ctx.lineTo(ris[2], ris[3]);
                            ctx.strokeStyle = 'white';
                            ctx.stroke();
                        }
                    }
                }else{
                    for (let x = gridXfin + this.offsetViewX; x <= gridXini + this.offsetViewX; x += dimCols) {
                        let yGrigliaSopra = gridYini + this.offsetViewY;
                        let yGrigliaSotto = gridYfin + this.offsetViewY;
    
                        let ris = drawInsideRectangle(this, x, yGrigliaSopra, x, yGrigliaSotto);
                        if(ris != null){
                            ctx.beginPath();
                            ctx.moveTo(ris[0], ris[1]);
                            ctx.lineTo(ris[2], ris[3]);
                            ctx.strokeStyle = 'black';
                            ctx.stroke();
                        }
                    }
                }
                ctx.restore();
                
            }
    
            drawAxes(gridXini, gridXfin, gridYini, gridYfin) {
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
    
                ctx.save();

                ctx.beginPath();
                ctx.rect(this.x, this.y, this.width, this.height);
                ctx.clip();
    
                const startX = gridXini + this.offsetViewX;
                const endX = gridXfin + this.offsetViewX;
                const centerY = (gridYini + gridYfin) / 2 + this.offsetViewY;
    
                let ris = drawInsideRectangle(this, startX, centerY, endX, centerY);
                if(ris != null){
                    ctx.beginPath();
                    ctx.moveTo(ris[0], ris[1]);
                    ctx.lineTo(ris[2], ris[3]);
                    ctx.stroke();
                }
    
                ctx.restore();
                
                ctx.save();
                ctx.beginPath();
                ctx.rect(this.x, this.y, this.width, this.height);
                ctx.clip();
    
                const startY = gridYini + this.offsetViewY;
                const endY = gridYfin + this.offsetViewY;
                const originX = gridXini + this.offsetViewX;
    
                ris = drawInsideRectangle(this, originX, startY, originX, endY);
                if(ris != null){
                ctx.beginPath();
                ctx.moveTo(ris[0], ris[1]);
                ctx.lineTo(ris[2], ris[3]);
                ctx.stroke();
                }
    
                ctx.restore();
            }
    
        
    
            moveRect(dx, dy) {
                if(!continuosOptions.includes(selectOption.value)){
                    if(this.x + dx >= 0 && this.y + dy >= 0 && this.x + this.width + dx <= canvas.width && this.y + this.height + dy <= canvas.height){
                        this.x += dx;
                        this.y += dy;
                        this.gridXini += dx;
                        this.gridXfin += dx;
                        this.gridYini += dy;
                        this.gridYfin += dy;
                    }
                }else{
                    if(this.x + dx >= 0 && this.y + dy >= 0 && this.x + this.width + dx <= canvas.width && this.y + this.height + dy <= canvas.height){
                        this.x += dx;
                        this.y += dy;
                        this.gridXini += dx;
                        this.gridXfin += dx;
                        this.gridYini += dy;
                        this.gridYfin += dy;
                        this.gxi += dx;
                        this.gxf += dx;
                        this.gyi += dy;
                        this.gyf += dy;
                    }
                }
            }
        }
    
        const canvas = document.getElementById("myCanvas");
        const ctx = canvas.getContext("2d");
    
        let isDragging = false;
        let isDraggingView = false;
        let isResizingBottomRight = false;
        let selectedRect = null;
        let lastMouseX, lastMouseY;
        let timer = null;
    
        const objects = [];
    
        var N = 0;
        var M = 0;
        var lambda = 0;
        var A = 0;
        var P = 0;
        var theta = 0;
        var muV = 0;
        var sigmaV = 0;
        var dataCollector = [];
        var drawDataset = [];
        let colori = [];
        var K = 0;
    
        var intervalsNumber = 20;
        var count={};
        var count3={};
        var count4={};
        var dataForHistogram;
        var labelsForHistogram;
        var dataForHistogramFine;
        var labelsForHistogramFine;
        let maxRows = 0;
        let continuosOptions = ["option8", "option2", "option1", "option4", "option5", "option3"];
            
        const rect2 = new Rect(100, 50, window.innerWidth * 0.9, window.innerHeight * 0.5, 2);
    
        objects.push(rect2);
    
        function drawRectangle(rect) {
            "use strict";
            rect.draw();
        }
                                                          
    
        function histogramData(pos){
            "use strict";
            if(!continuosOptions.includes(selectOption.value)){
                count={};
                var errore = 0;
                for(var m = 0; m < M; m++){
                    for(var c=-N; c<(N); c++){
                        var inizio = (c).toFixed(1);
                        var fine = (c+1).toFixed(1);
                        var key = `${inizio}/${fine}`;
                        if(dataCollector[m][1][pos-1]>=inizio && dataCollector[m][1][pos-1]<fine){
                            if (count[key]) {
                                count[key] += 1;
                            } else {
                                count[key] = 1;
                            }
                        }else if(dataCollector[m][1][pos-1] == fine){
                            if(pos == N){
                                if(dataCollector[m][1][pos-1] == pos){
                                    if (count[`${fine}/${fine+1}`]) {
                                        count[`${fine}/${fine+1}`] += 1;
                                    } else {
                                        count[`${fine}/${fine+1}`] = 1;
                                    }
                                }
                            }
                        }
                    }          
                }
                if(pos != N){
                    dataForHistogram = Object.values(count);
                    labelsForHistogram = Object.keys(count);
                }else{
                    dataForHistogramFine = Object.values(count);
                    labelsForHistogramFine = Object.keys(count);
                }
            }else{
                count={};
                let interval = 2;
                for(var m = 0; m < M; m++){
                    for(var c=(-maxRows); c<(maxRows); c += interval){
                        var inizio = (c).toFixed(2);
                        var fine = (c+interval).toFixed(2);
                        var key = `${inizio}/${fine}`;
                        if(dataCollector[m][1][pos-1]>=inizio && dataCollector[m][1][pos-1]<fine){
                            if (count[key]) {
                                count[key] += 1;
                            } else {
                                count[key] = 1;
                            }
                        }else if(dataCollector[m][1][pos-1] == fine){
                            if(pos == N){
                                if(dataCollector[m][1][pos-1] == pos){
                                    if (count[`${fine}/${fine+1}`]) {
                                        count[`${fine}/${fine+1}`] += 1;
                                    } else {
                                        count[`${fine}/${fine+1}`] = 1;
                                    }
                                }
                            }
                        }
                    }          
                }
                if(pos != N){
                    dataForHistogram = Object.values(count);
                    labelsForHistogram = Object.keys(count);
                }else{
                    dataForHistogramFine = Object.values(count);
                    labelsForHistogramFine = Object.keys(count);
                }
            }
        }

        function findMinandMax(){
            let min = parseFloat("Infinity");
            let max = -parseFloat("Infinity");
            if(continuosOptions.includes(selectOption.value)){
                for(let m = 0; m < M; m++){
                    for(let n = 0; n < N; n++){
                        if(dataCollector[m][1][n] > max){
                            max = dataCollector[m][1][n];
                        }
                        if(dataCollector[m][1][n] < min){
                            min = dataCollector[m][1][n];
                        }
                    }
                }
            }   

            if(Math.abs(Math.ceil(min)-1) > Math.abs(Math.ceil(max))){
                return Math.abs(Math.ceil(min)-1);
            }else{
                return Math.abs(Math.ceil(max));
            }
        }

        function collectData(){
            "use strict";
            N = parseInt(document.getElementById("numberN").value);
            M = parseInt(document.getElementById("numberM").value);
            P = parseFloat(document.getElementById("Probability").value);
            A = parseInt(document.getElementById("numberA").value);
            lambda = parseInt(document.getElementById("Lambda").value);
            muV = parseFloat(document.getElementById("muValue").value);
            sigmaV = parseFloat(document.getElementById("sigmaValue").value);
            theta = parseFloat(document.getElementById("thetaValue").value);
            K = parseFloat(document.getElementById("kValue").value);

            dataCollector=[new Array(M).fill(0)];
            drawDataset = [];
            for(let i = 0; i < N; i++){
                drawDataset[i] = [];
            }
            for(let i = 0; i < N; i++){
                for(let i = 0; i < N; i++){
                    drawDataset[i].push(0);
                }
            }
    
            for (let m = 0; m < M; m++) {
                dataCollector[m]=[new Array(M).fill(0)];
                var data2 = [];
                var counter = new Array(N).fill(0);
    
                for (let n = 0; n < N; n++) {
                    const randomNumber = Math.random();
                
                    var result2 = 0;
                    
                    if(selectOption.value=="option6"){
                        if(randomNumber <= P){
                            result2 = 1;
                        }else{
                            result2 = 0;
                        }
                    }

                    if(selectOption.value=="option7"){
                        if(randomNumber <= P){
                            result2 = 1;
                        }else{
                            result2 = -1;
                        }
                    }

                    if(selectOption.value=="option1"){  //general brawnian motion
                        const mu = N * P;
                        const sigma = Math.sqrt(N * P * (1 - P));
                        const u1 = Math.random();
                        const u2 = Math.random();
                        const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                        let ris = mu + sigma * z;
                        if(randomNumber <= P){
                            result2 = (1/Math.sqrt(N))*ris;
                        }else{
                            result2 = -(1/Math.sqrt(N))*ris;
                        }
                    }

                    if(selectOption.value=="option8"){  //Poisson
                        P = lambda / N;
                        if(randomNumber <= P){
                            result2 = 1;
                        }else{
                            result2 = 0;
                        }
                    }

                    if(selectOption.value=="option2"){  //standard brawnian motion
                        const u1 = Math.random();
                        const u2 = Math.random();
                        const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                        
                        if(randomNumber <= P){
                            result2 = z;
                        }else{
                            result2 = -z;
                        }
                    }

                    if(selectOption.value=="option3"){  
                        const u1 = Math.random(); 
                        const u2 = Math.random(); 
                        const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2); 
                        const deltaS = muV + sigmaV * z; 
                        const ris = Math.exp(deltaS); 
                        if (randomNumber <= P) { 
                            result2 = ris; 
                        } else { 
                            result2 = -ris; 
                        }
                        
                    }

                    if(selectOption.value=="option4"){  
                        const u1 = Math.random(); 
                        const u2 = Math.random(); 
                        const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2); 

                        let delta = theta * (muV) + sigmaV * z;
                        if(n!=0){
                            delta = theta * (muV - data2[n-1]) + sigmaV * z;
                        }
                        
                        if (randomNumber <= P) { 
                            result2 = 1 + delta; 
                        }
                    }

                    if(selectOption.value=="option5"){  
                        const u1 = Math.random(); 
                        const u2 = Math.random(); 
                        const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2); 

                        let delta = K * theta + sigmaV * z;
                        if(n!=0){
                            delta = K * (theta - data2[n-1]) + sigmaV * z;
                        }
                        
                        if (randomNumber <= P) { 
                            result2 = 1 + delta; 
                        }
                    }
                    
                    if(n==0){
                        data2.push(result2);
                    }else{
                        data2.push(data2[n-1]+result2);
                    }
                }
                dataCollector[m][1]=data2;
            }
    
            for (let m = 0; m < M; m++) {
                var letters = '0123456789ABCDEF';
                var color = '#';
                for (let i = 0; i < 6; i++) {
                    color += letters[Math.floor(Math.random() * 16)];
                }
                colori.push(color);
            }

            let min_max = findMinandMax();
            maxRows = min_max;
    
            histogramData(A);
            histogramData(N);


            if(continuosOptions.includes(selectOption.value)){
                rect2.gxi = rect2.gridXini;
                rect2.gxf = rect2.gridXfin;
                rect2.gyi = rect2.gridYini - (((rect2.gridYfin-rect2.gridYini)/2)/N)*min_max;
                rect2.gyf = rect2.gridYfin + (((rect2.gridYfin-rect2.gridYini)/2)/N)*min_max;
            }
    
            ctx.clearRect(0,0,canvas.width,canvas.height);
            drawRectangle(rect2);
        }
    

        function drawInsideRectangle(rect, x_ini, y_ini, x_fin, y_fin){
            ris_x_ini = x_ini;
            ris_y_ini = y_ini;
            ris_x_fin = x_fin;
            ris_y_fin = y_fin;
            ris = null;
        
            if(rect.width >= 0){
                if(rect.height >= 0){
                    if(x_ini < rect.x){
                        ris_x_ini = rect.x;
                    }
                    if(x_fin > rect.w + rect.width){
                        ris_x_fin = rect.x + rect.width;
                    }
                    if(y_ini < rect.y){
                        ris_y_ini = rect.y;
                    }
                    if(y_fin > rect.y + rect.height){
                        ris_y_fin = rect.y + rect.height;
                    }
                    ris = [ris_x_ini, ris_y_ini, ris_x_fin, ris_y_fin];
                    if(x_ini < rect.x && x_fin < rect.x){
                        ris = null;
                    }
                    if(x_ini > (rect.x + rect.width) && x_fin > (rect.x + rect.width)){
                        ris = null;
                    }
                    if(y_ini < rect.y && y_fin < rect.y){
                        ris = null;
                    }
                    if(y_ini > (rect.y + rect.height) && y_fin > (rect.y + rect.height)){
                        ris = null;
                    }
                }else{
                    if(x_ini < rect.x){
                        ris_x_ini = rect.x;
                    }
                    if(x_fin > rect.w + rect.width){
                        ris_x_fin = rect.x + rect.width;
                    }
                    if(y_ini > rect.y){
                        ris_y_ini = rect.y;
                    }
                    if(y_fin < rect.y + rect.height){
                        ris_y_fin = rect.y + rect.height;
                    }
                    ris = [ris_x_ini, ris_y_ini, ris_x_fin, ris_y_fin];
                    if(x_ini < rect.x && x_fin < rect.x){
                        ris = null;
                    }
                    if(x_ini > (rect.x + rect.width) && x_fin > (rect.x + rect.width)){
                        ris = null;
                    }
                    if(y_ini > rect.y && y_fin > rect.y){
                        ris = null;
                    }
                    if(y_ini < (rect.y + rect.height) && y_fin < (rect.y + rect.height)){
                        ris = null;
                    }
                }
            }else{
                if(rect.height >= 0){
                    if(x_ini > rect.x){
                        ris_x_ini = rect.x;
                    }
                    if(x_fin < rect.w + rect.width){
                        ris_x_fin = rect.x + rect.width;
                    }
                    if(y_ini < rect.y){
                        ris_y_ini = rect.y;
                    }
                    if(y_fin > rect.y + rect.height){
                        ris_y_fin = rect.y + rect.height;
                    }
                    ris = [ris_x_ini, ris_y_ini, ris_x_fin, ris_y_fin];
                    if(x_ini > rect.x && x_fin > rect.x){
                        ris = null;
                    }
                    if(x_ini < (rect.x + rect.width) && x_fin < (rect.x + rect.width)){
                        ris = null;
                    }
                    if(y_ini < rect.y && y_fin < rect.y){
                        ris = null;
                    }
                    if(y_ini > (rect.y + rect.height) && y_fin > (rect.y + rect.height)){
                        ris = null;
                    }
                }else{
                    if(x_ini > rect.x){
                        ris_x_ini = rect.x;
                    }
                    if(x_fin < rect.w + rect.width){
                        ris_x_fin = rect.x + rect.width;
                    }
                    if(y_ini > rect.y){
                        ris_y_ini = rect.y;
                    }
                    if(y_fin < rect.y + rect.height){
                        ris_y_fin = rect.y + rect.height;
                    }
                    ris = [ris_x_ini, ris_y_ini, ris_x_fin, ris_y_fin];
                    if(x_ini > rect.x && x_fin > rect.x){
                        ris = null;
                    }
                    if(x_ini < (rect.x + rect.width) && x_fin < (rect.x + rect.width)){
                        ris = null;
                    }
                    if(y_ini > rect.y && y_fin > rect.y){
                        ris = null;
                    }
                    if(y_ini < (rect.y + rect.height) && y_fin < (rect.y + rect.height)){
                        ris = null;
                    }
                }
            }
            return ris;
        }

        function addIfAlreadyDraw(m, n, passoX, passoY, v){
            if(!continuosOptions.includes(selectOption.value)){
                if(v == 0){
                    if(dataCollector[m][1][n] - dataCollector[m][1][n-1] > 0){    
                        let riga = dataCollector[m][1][n] - passoY;
                        let colonna = n - passoX;
                        drawDataset[riga][colonna] = 1;
                    }
                    if(dataCollector[m][1][n] - dataCollector[m][1][n-1] == 0){    
                        let riga = dataCollector[m][1][n];
                        let colonna = n - passoX;
                        drawDataset[riga][colonna] = 1;
                    }
                    if(dataCollector[m][1][n] - dataCollector[m][1][n-1] < 0){    
                        let riga = dataCollector[m][1][n] + passoY;
                        let colonna = n - passoX;
                        drawDataset[riga][colonna] = 1;
                    }
                }else{
                    drawDataset[dataCollector[m][1][n]][n] = 1;
                }
            }
        }

        function checkIfAlreadyDraw(m, n, passoX, passoY){
            if(!continuosOptions.includes(selectOption.value)){
                if(dataCollector[m][1][n] - dataCollector[m][1][n-1] > 0){    
                    let riga = dataCollector[m][1][n] - passoY;
                    let colonna = n - passoX;
                    if(drawDataset[riga][colonna] == 0){
                        drawDataset[riga][colonna] = 1;
                        return true
                    }
                }
                if(dataCollector[m][1][n] - dataCollector[m][1][n-1] == 0){    
                    let riga = dataCollector[m][1][n];
                    let colonna = n - passoX;
                    if(drawDataset[riga][colonna] == 0){
                        drawDataset[riga][colonna] = 1;
                        return true;
                    }
                }
                if(dataCollector[m][1][n] - dataCollector[m][1][n-1] < 0){    
                    let riga = dataCollector[m][1][n] + passoY;
                    let colonna = n - passoX;
                    if(drawDataset[riga][colonna] == 0){
                        drawDataset[riga][colonna] = 1;
                        return true;
                    }
                }
                return false;
            }else{
                return false;
            }
        }

        function drawn(m, n){
            if(!continuosOptions.includes(selectOption.value)){
                if(drawDataset[dataCollector[m][1][n]][n] == 0){
                    return true;
                }else{
                    return false;
                }
            }else{
                return true;
            }
        }

        function drawHistogram(rect, pos, data, labels){
            "use strict";
            if(!continuosOptions.includes(selectOption.value)){
                let factorX = (rect.gridXfin - rect.gridXini)/N;
                let factorY = ((rect.gridYfin - rect.gridYini)/2)/N;
                let factorXHistogram = ((rect.gridXfin - rect.gridXini) / N);
                let barHeight = (((rect.gridYfin - rect.gridYini) / N) / 2.5);

                ctx.save();
                ctx.beginPath();
                ctx.rect(rect.x, rect.y, rect.width, rect.height);
                ctx.clip();
        
                if(rect.id == 2){
                    for (let i = 0; i < data.length; i++) {
                        var p = parseFloat((labels[i].split('/'))[0]);
                        const barWidth  = (data[i] ) * factorXHistogram;
        
                        let x = (rect.gridXini + rect.offsetViewX) + (pos)*factorXHistogram;
                        let y = (rect.gridYini + rect.offsetViewY) + (rect.gridYfin - rect.gridYini)/2 - barHeight - p*factorY;
        
                        ctx.fillStyle = "rgba(0, 0, 255, 0.8)"; 
                        ctx.fillRect(x, y, barWidth, barHeight);
                        ctx.fillStyle = "black";
                        ctx.textAlign = "center";
                        ctx.fillText(data[i], x, y);
                        ctx.stroke();
                    } 
                } 
                ctx.restore();
            }else{
                let factorX = (rect.gridXfin - rect.gridXini)/N;
                let factorY = (((rect.gridYfin - rect.gridYini)/2)/N);
                let factorXHistogram = ((rect.gridXfin - rect.gridXini) / N);
                let barHeight = (factorY*2) - factorY/8;

                ctx.save();
                ctx.beginPath();
                ctx.rect(rect.x, rect.y, rect.width, rect.height);
                ctx.clip();
        
                if(rect.id == 2){
                    for (let i = 0; i < data.length; i++) {
                        var p = parseFloat((labels[i].split('/'))[0]);
                        const barWidth  = (data[i]) * factorXHistogram;
        
                        let x = (rect.gridXini + rect.offsetViewX) + (pos)*factorXHistogram;
                        let y = (rect.gridYini + rect.offsetViewY) + (rect.gridYfin - rect.gridYini)/2 - barHeight - p*factorY;
        
                        ctx.fillStyle = "rgba(0, 0, 255, 0.8)"; 
                        ctx.fillRect(x, y, barWidth, barHeight);
                        ctx.fillStyle = "black";
                        ctx.textAlign = "center";
                        ctx.fillText(data[i], x, y);
                        ctx.stroke();
                    } 
                } 
                ctx.restore();
            }
        }
    
        function drawChart(rect) {  
            "use strict";     
            drawDataset = [];
            const passoX = 0.5;
            const passoY = 0.5;
            for(let i = -N; i <= N; i += passoY){
                drawDataset[i] = [];
                let arr = [];
                for(let j = 0; j <= N; j += passoX){
                    arr[j] = 0;
                }
                drawDataset[i] = arr;
            }
            for(let i = -N; i <= N; i += passoY){
                for(let j = 0; j <= N; j += passoX){
                    drawDataset[i][j] = 0;
                }
            }
    
            let factorX = (rect.gridXfin - rect.gridXini)/N;
            let factorY = ((rect.gridYfin - rect.gridYini)/2)/N;
            for (let n = 0; n < N; n++) {            
                for(let m = 0; m < M; m++){
                    if(drawn(m, n)){
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(rect.x, rect.y, rect.width, rect.height);
                        ctx.clip();
                        ctx.strokeStyle = colori[m];
                        let a = rect.gridXini + rect.offsetViewX;   //x_ini
                        let b = rect.gridYini + rect.offsetViewY;   //y_ini
                        let c = rect.gridYfin - rect.gridYini;      //height
                        if(n==0){
                            if(rect.id==2){
                                let ris = drawInsideRectangle(rect, n*factorX + a, b + c/2, (n+1)*factorX + a, -(dataCollector[m][1][n])*factorY + b + c/2);
                                addIfAlreadyDraw(m, n, passoX, passoY, 0)
    
                                if(ris != null){
                                    ctx.moveTo(ris[0], ris[1]);
                                    ctx.lineTo(ris[2], ris[3]);
                                    ctx.stroke();
                                }
                            }
                        }else{
                            if(rect.id==2){
                                let ris = drawInsideRectangle(rect, n*factorX + a, -(dataCollector[m][1][n-1])*factorY + b + c/2, (n+1)*factorX + a, -(dataCollector[m][1][n])*factorY + b + c/2);
                                addIfAlreadyDraw(m, n, passoX, passoY, 0)
                                
                                if(ris != null){
                                    ctx.moveTo(ris[0], ris[1]);
                                    ctx.lineTo(ris[2], ris[3]);
                                    ctx.stroke();
                                }
                            }
                        }
                        addIfAlreadyDraw(m, n, passoX, passoY, 1)
                        ctx.restore();
                    }else{
                        
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(rect.x, rect.y, rect.width, rect.height);
                        ctx.clip();
                        ctx.strokeStyle = colori[m];
                        let a = rect.gridXini + rect.offsetViewX;   //x_ini
                        let b = rect.gridYini + rect.offsetViewY;   //y_ini
                        let c = rect.gridYfin - rect.gridYini;      //height
                        if(rect.id==2){
                            if(checkIfAlreadyDraw(m, n, passoX, passoY)){
                                let ris = drawInsideRectangle(rect, n*factorX + a, -(dataCollector[m][1][n-1])*factorY + b + c/2, (n+1)*factorX + a, -(dataCollector[m][1][n])*factorY + b + c/2);
                                if(ris != null){
                                    ctx.moveTo(ris[0], ris[1]);
                                    ctx.lineTo(ris[2], ris[3]);
                                    ctx.stroke();
                                }
                            }
                        }
                        ctx.restore();
                    }
                }
            }
        }
    
        function drawRectanglePerimeter(rect) {    
            "use strict";   
    
            ctx.save();
            ctx.beginPath();
            ctx.rect(rect.x, rect.y, rect.width, rect.height);
            ctx.clip();
            
            ctx.strokeStyle = "black";
            ctx.stroke();
            
            ctx.restore();
        }
    
    
        canvas.addEventListener("mousedown", (e) => {
            const mouseX = e.clientX - canvas.getBoundingClientRect().left;
            const mouseY = e.clientY - canvas.getBoundingClientRect().top;
    
            if (e.button === 0) { 
                selectedRect = findSelectedObject(mouseX, mouseY);
                if(selectedRect){
                    if( mouseX < selectedRect.x + selectedRect.width + 10 && mouseX > selectedRect.x + selectedRect.width - 10 && mouseY < selectedRect.y + selectedRect.height + 10 && mouseY > selectedRect.y + selectedRect.height - 10){
                        isResizingBottomRight = true;
                        lastMouseX = mouseX;
                        lastMouseY = mouseY;
                    }else{
                        isDragging = true;
                        lastMouseX = mouseX;
                        lastMouseY = mouseY;
                    }
                }
            } else if(e.button === 2){  
                selectedRect = findSelectedObject(mouseX, mouseY);
                if(selectedRect){
                    isDraggingView = true;
                    lastMouseX = mouseX;
                    lastMouseY = mouseY;
                }
            }
            e.preventDefault();
        });
    
        function findSelectedObject(x, y) {
            "use strict";
            let offset = 10;
            for (let i = objects.length - 1; i >= 0; i--) {
                const rect = objects[i];
                if(rect.width >= 0){
                    if(rect.height >= 0){
                        if ( x >= rect.x && x <= rect.x + rect.width + offset && y >= rect.y && y <= rect.y + rect.height + offset ) return rect;
                    }else{
                        if ( x >= rect.x && x <= rect.x + rect.width + offset && y <= rect.y && y >= rect.y + rect.height - offset ) return rect;
                    }
                }else{
                    if(rect.height >= 0){
                        if ( x <= rect.x && x >= rect.x + rect.width - offset && y >= rect.y && y <= rect.y + rect.height + offset ) return rect;
                    }else{
                        if ( x <= rect.x && x >= rect.x + rect.width - offset && y <= rect.y && y >= rect.y + rect.height - offset ) return rect;
                    }
                }
            }
            return null;
        }
    
        function findBelowObject(rect){
            "use strict";
            for (let i = objects.length - 1; i >= 0; i--) {
                const object = objects[i];
                if(object.id != rect.id){
                    if ( 
                        rect.x + rect.width > object.x && rect.x < object.x + object.width && rect.y + rect.height > object.y && rect.y < object.y + object.height
                     ) {
                        return object;
                    }
                    if ( 
                        object.x + object.width > rect.x && object.x < rect.x + rect.width && object.y + object.height > rect.y && object.y < rect.y + rect.height
                     ) {
                        return object;
                    }
                }
            }
            return null;
        }
    
        function clearRectangle(rect){
            "use strict";
            if(rect.width < 0){
                if(rect.height >= 0){
                    ctx.clearRect(rect.x + rect.width, rect.y, rect.x, rect.y + rect.height);
                }else{
                    ctx.clearRect(rect.x + rect.width, rect.y + rect.height, rect.x, rect.y);
                }
            }else{
                if(rect.height >= 0){
                    ctx.clearRect(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height);
                }else{
                    ctx.clearRect(rect.x, rect.y + rect.height, rect.x + rect.width, rect.y);
                }
            }
        }
    
        function resizeRect(rect, mouseX, mouseY) {
            "use strict";
            clearRectangle(rect);
    
            if(continuosOptions.includes(selectOption.value)){ 
                rect.gridXfin += mouseX - lastMouseX; 
                rect.gridYfin += mouseY - lastMouseY; 
                rect.gxf += mouseX - lastMouseX; 
                rect.gyf += mouseY - lastMouseY; 
                rect.width += mouseX - lastMouseX; 
                rect.height += mouseY - lastMouseY; 
            }else{ 
                rect.gridXfin += mouseX - lastMouseX; 
                rect.gridYfin += mouseY - lastMouseY; 
                rect.width += mouseX - lastMouseX; 
                rect.height += mouseY - lastMouseY; 
            }
            drawRectanglePerimeter(rect);
        }
    
        function dragView(rect, mouseX, mouseY){
            "use strict";
            clearRectangle(rect);
            rect.offsetViewX += mouseX - lastMouseX;
            rect.offsetViewY += mouseY - lastMouseY;
            drawRectanglePerimeter(rect);
        }
    
        function dragRectangle(rect, mouseX, mouseY){
            "use strict";
            let dx = mouseX - lastMouseX;
            let dy = mouseY - lastMouseY;
            clearRectangle(rect);
            rect.moveRect(dx, dy);
            drawRectanglePerimeter(rect);
        }
    
    
        var contatore = 0;
        canvas.addEventListener("mousemove", (e) => {
            const mouseX = e.clientX - canvas.getBoundingClientRect().left;
            const mouseY = e.clientY - canvas.getBoundingClientRect().top;
            
            if (isDragging) {
                if (selectedRect) {
                    dragRectangle(selectedRect, mouseX, mouseY);
                }
            } else if (isDraggingView) {
                if (selectedRect) {
                    dragView(selectedRect, mouseX, mouseY);
                }
                
            }else if(isResizingBottomRight){
                if(selectedRect){
                    resizeRect(selectedRect, mouseX, mouseY);
                }
                
            }
            lastMouseX = mouseX;
            lastMouseY = mouseY;
            e.preventDefault();
        });
    
        canvas.addEventListener("mouseup", () => {
            isDragging = false;
            isDraggingView = false;
            isResizingBottomRight = false;
            selectedRect = findSelectedObject(lastMouseX, lastMouseY);
            if(selectedRect){
                drawRectangle(selectedRect);
            }
        });

    
        canvas.addEventListener("contextmenu", (e) => {
            e.preventDefault();
        });
    </script>
</html>